name: Deploy Docker image to EKS

on:
  workflow_call:
    inputs:
      image_version:
        required: true
        type: string
      environment:
        required: true
        type: string
      cluster_name:
        required: true
        type: string
      service_name:
        required: true
        type: string
      eks_config_branch:
        type: string
        required: false
        default: "develop"
      aws_account_id:
        required: true
        type: string
      aws_account_id_ecr:
        required: false
        type: string
        default: "794071690772"
      kubctl_download_url:
        required: true
        type: string
      iam_role:
        required: false
        type: string
        default: ""
      github_actions_deploy_timeout:
        required: true
        type: string
      core_deployment_type:
        required: false
        type: string
        default: "both"
      local_runner:
        required: false
        type: string
        default: "self-hosted-runner-standard-v2"
      namespace_prefix:
          required: false
          type: string
          default: "littera-services"
      github_oidc_role:
        required: true
        type: string

    secrets:
      repo_token:
        required: true
      NEW_RELIC_LICENSE_KEY:
        required: false

jobs:
  deploy-to-eks:
    name: Deploy ${{ inputs.image_version }} to ${{ inputs.environment }}
    runs-on: ${{ inputs.local_runner }}

    permissions:
      id-token: write

    steps:

      - name: Install curl, wget and unzip
        run: |
          sudo apt-get update
          sudo apt-get install -y curl wget unzip

      - name: Get runner arch
        id: runner_arch
        run: |
          arch_value=$(uname -m)
          if [ "$arch_value" = "x86_64" ]; then
            echo "runner_arch=amd64" >> $GITHUB_OUTPUT
          elif [ "$arch_value" = "aarch64" ]; then
            echo "runner_arch=arm64" >> $GITHUB_OUTPUT
          fi

      - name: Setup aws cli
        uses: unfor19/install-aws-cli-action@v1
        with:
          version: 2
          arch: ${{ steps.runner_arch.outputs.runner_arch }}
          
      - name: Configure AWS Creds
        uses: aws-actions/configure-aws-credentials@v4.0.2
        with:
          aws-region: us-east-1
          role-to-assume: ${{ inputs.github_oidc_role }}

      - name: Checkout EKS Config Repo/'develop' branch
        uses: actions/checkout@v4
        with:
          repository: Littera-Education/littera-eks-config
          token: ${{ secrets.repo_token }}
          ref: ${{ inputs.eks_config_branch }}
          path: config
          fetch-depth: 0

      - name: Install wget, curl and unzip
        run: |
          sudo apt-get update
          sudo apt-get install -y wget curl unzip

      - name: Install yq
        env:
          YQ_VERSION: v4.27.2
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq
  
      - name: Update Deployment and/or ConfigMap
        env:
          service_name: ${{ inputs.service_name }}
          image_version: ${{ inputs.image_version }}
          environment: ${{ inputs.environment }}
          aws_account_id_ecr: ${{ inputs.aws_account_id_ecr }}
          create_substring: "created (server dry run)"
          change_substring: "configured (server dry run)"
          no_change_substring: "unchanged (server dry run)"
          kubctl_download_url: ${{ inputs.kubctl_download_url }}
          cluster_name: ${{ inputs.cluster_name }}
          github_actions_deploy_timeout: ${{ inputs.github_actions_deploy_timeout }}
          namespace_prefix: ${{ inputs.namespace_prefix }}
        run: |
          set -e

          # install kubectl
          curl -o kubectl $kubctl_download_url
          chmod +x ./kubectl
          mkdir -p $HOME/bin && mv ./kubectl $HOME/bin/kubectl && export PATH=$HOME/bin:$PATH

          manifest_path="config/$service_name/eks/eks-$environment-deployment.yaml"

          # set and use kube context
          aws eks --region us-east-1 update-kubeconfig --name $cluster_name

          kubectl version

          # edit ECR image path in eks manifest file
          if [[ $service_name == "littera-core-api" ]]; then
              sed -i "s|image:\s*.*|image: $aws_account_id_ecr.dkr.ecr.us-east-1.amazonaws.com/littera-core:$image_version|" $manifest_path
          else
              sed -i "s|image:\s*.*|image: $aws_account_id_ecr.dkr.ecr.us-east-1.amazonaws.com/$service_name:$image_version|" $manifest_path
          fi

          # add image version to the datadog 'version' label
          sed -i "s|tags.datadoghq.com/version:\s*.*|tags.datadoghq.com/version: $image_version|" $manifest_path

          yq eval 'select(.kind == "Deployment")' "$manifest_path" > deployments.yaml
          if [ -s deployments.yaml ]; then
              deployment_diff=$(kubectl diff -f deployments.yaml || true)
              echo deployment_diff: ${#deployment_diff}
              if [[ -z "$deployment_diff" ]]; then
                  deployment_restart=false
              else
                  deployment_restart=true
              fi
              echo deployment_restart: "$deployment_restart"
          fi
          
          yq eval 'select(.kind == "ConfigMap")' "$manifest_path" > configmaps.yaml
          if [ -s configmaps.yaml ]; then
              configmap_diff=$(kubectl diff -f configmaps.yaml || true)
              echo configmap_diff: ${#configmap_diff}
              if [[ -z "$configmap_diff" ]]; then
                if echo "${image_version}" | grep -qE ".*-SNAPSHOT$"; then
                  configmap_restart=true
                else
                  configmap_restart=false
                fi
              else
                  configmap_restart=true
              fi
              echo configmap_restart: "$configmap_restart"
          fi

          echo " "
          echo "***************************************************************************************************"
          echo "NOTE: If the action fails due to the timeout of $github_actions_deploy_timeout,"
          echo "the deployment may still have succeeded. Please contact devops in #team-devops-collab about this"
          echo "***************************************************************************************************"
          echo " "

          if [[ $deployment_restart == true ]] ; then
              echo "deployment will initiate a rolling restart"
              kubectl apply -f configmaps.yaml
              kubectl apply -f deployments.yaml
              if [[ $service_name == "littera-core-api" ]]; then
                  kubectl rollout status deployment/littera-core-web deployment/littera-core-worker -n $namespace_prefix-$environment
              else
                  kubectl rollout status deployment $service_name -n $namespace_prefix-$environment
              fi

          elif [[ $deployment_restart == false && $configmap_restart == true ]]; then
              echo "An explicit rolling restart will be initiated"
              kubectl apply -f configmaps.yaml
              if [[ $service_name == "littera-core-api" ]]; then
                  kubectl rollout restart deployment littera-core-web -n $namespace_prefix-$environment
                  kubectl rollout restart deployment littera-core-worker -n $namespace_prefix-$environment
                  kubectl rollout status deployment/littera-core-web deployment/littera-core-worker -n $namespace_prefix-$environment
              else
                  kubectl rollout restart deployment $service_name -n $namespace_prefix-$environment
                  kubectl rollout status deployment $service_name -n $namespace_prefix-$environment
              fi
          fi

          if [[ $deployment_restart == false && $configmap_restart == false ]]; then
              echo "No changes detected in the deployment or configmap"
          fi
      
      - name: Tag ECR image with environment
        run: |
          set -e

          # This form of token is needed for the ECR API
          AUTH_TOKEN=$(aws ecr get-authorization-token --output text --query 'authorizationData[].authorizationToken')

          # Set registry and repository details
          REGISTRY_NAME="https://${{ inputs.aws_account_id_ecr }}.dkr.ecr.us-east-1.amazonaws.com"
          TAG="${{ inputs.image_version }}"
          ENVIRONMENT_TAG="${{ inputs.environment }}"
          CONTENT_TYPE="application/vnd.docker.distribution.manifest.v2+json"

          if [[ "${{ inputs.service_name }}" == "littera-core-api" ]]; then
            REPOSITORY="littera-core"
          else
            REPOSITORY="${{ inputs.service_name }}"
          fi

          # Fetch the manifest of the existing image
          MANIFEST=$(curl -s -H "Authorization: Basic $AUTH_TOKEN" -H "Accept: $CONTENT_TYPE" "$REGISTRY_NAME/v2/$REPOSITORY/manifests/$TAG")

          # Check for curl failure
          if [ $? -ne 0 ]; then
            echo "Failed to fetch the manifest for tag $TAG."
            exit 1
          fi

          echo MANIFEST: $MANIFEST

          # Push the fetched manifest as a new tag
          RESPONSE_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X PUT -H "Authorization: Basic $AUTH_TOKEN" -H "Content-Type: $CONTENT_TYPE" -d "$MANIFEST" "$REGISTRY_NAME/v2/$REPOSITORY/manifests/$ENVIRONMENT_TAG")
          
          # Check if the image retagging was successful
          if [ "$RESPONSE_CODE" != "201" ]; then
            echo "Failed to tag image, server responded with status code $RESPONSE_CODE."
            exit 1
          fi
          echo "Image $TAG tagged $ENVIRONMENT_TAG."